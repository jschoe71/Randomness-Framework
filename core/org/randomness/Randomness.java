package org.randomness;

import java.io.IOException;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.Channel;
import java.nio.channels.NonReadableChannelException;
import java.nio.channels.Pipe;
import java.nio.channels.Pipe.SinkChannel;
import java.nio.channels.Pipe.SourceChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.channels.ScatteringByteChannel;
import java.nio.channels.Selector;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.Future;
import java.util.concurrent.locks.ReentrantLock;

//import javolution.lang.Reusable;

/**
 * This class specifies basic <i>Random Bit Generator</i> (RBG) life cycle and
 * mechanisms for the generation of random bits.
 * <p>
 * A randomness represents an open connection to an entity such as a hardware
 * device, or an deterministic algorithm that is capable of producing random
 * output. Life cycle of Random Bit Generator inspired on NIST 800-90
 * Specification. The RBG mechanisms have four separate functions handle the
 * RBG’s <i>internal state</i>:
 * <ol>
 * <li>
 * The {@linkplain Randomness#reset() instantiate function} determines the
 * <i>initial internal state</i> of RBG using the instantiate algorithm. A RBG
 * shall be instantiated prior to the generation of random bits. Opposite to
 * {@linkplain Randomness#close() uninstantiate} function.</li>
 * <li>
 * The {@linkplain Randomness#read(ByteBuffer) generate function} generates
 * random bits upon request, using the current internal state, and generates a
 * new internal state for the next request. RBG <b>should</b> be
 * {@linkplain Randomness#reset() instantiate} before generation.</li>
 * <li>
 * The {@linkplain Randomness#close() uninstantiate function} zeroizes (i.e.,
 * erases) the internal state. A RBG uninstantiate function supports
 * asynchronous closing. Opposite to {@linkplain Randomness#reset() instantiate}
 * function.</li>
 * <li>
 * <p>
 * The health test function determines that the DRBG mechanism continues to
 * function correctly (optional).</li>
 * </ol>
 * <p>
 * Randomness can be represented in different views:
 * <ul>
 * <li>
 * The any RBG can be represented as equal {@link #asRandom() java.util.Random }
 * instance.
 * <li>
 * The {@linkplain #mixing(Randomness...) mixing} represents combination of
 * several DBG's output using <code>XOR</code> mixing function.
 * <li>
 * The {@linkplain #reversed(int) reversing} takes bytes generated by an
 * underling <code>Randomness</code> and reverses the order in each small window
 * of configurable size (byte-by-byte).
 * <li>
 * The {@linkplain #shuffle(Randomness) shuffling} uses one random number
 * generator to shuffle the output produced by another to obliterate sequential
 * correlations to produce non-linear output.
 * <li>
 * Future implementations:
 * <ul>
 * <li>The <code>unmodifiable</code> view over this RBG.
 * <li>NIO based {@linkplain #bind(SocketAddress) server}, associated with this
 * RBG.
 * <li>Buffered RBG uses internal buffer to provide randomness pool.
 * </ul>
 * </ul>
 * <p>
 * As specified in the {@link Channel} interface RBG are either open or closed,
 * and they are both asynchronously closeable and, in general, <b>should</b>
 * (intended) to be safe for multithreaded access.
 * 
 * @see <a href="http://en.wikipedia.org/wiki/Random_number_generator">Wikipedia
 *      - Random number generation</a>
 * @see <br>
 *      <a href=
 *      "http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90revised_March2007.pdf"
 *      >NIST Special Publication 800-90: Recommendation for Random Number
 *      Generation using Deterministic Random Bit Generators.</a>
 * @author <a href="mailto:Anton.Kabysh@gmail.com">Anton Kabysh</a> - Code,
 *         Specefication
 * @author <br>
 *         NIST 800-90 autors (Elaine Barker, John Kelsey) - Specification
 */
public abstract class Randomness implements Channel, /* Reusable, */
ReadableByteChannel, ScatteringByteChannel {

	// /////////////////////////////////////////////////////////////////////
	// //////////////////////// STATIC /////////////////////////////////////
	// /////////////////////////////////////////////////////////////////////

	static final int BITS_PER_BYTE = 8;
	static final int ONE_BYTE = 1;
	static final int SHORT_SIZE_BYTE = 2;
	static final int CHAR_SIZE_BYTE = 2;
	static final int INT_SIZE_BYTES = 4;
	static final int FLOAT_SIZE_BYTES = 4;
	static final int LONG_SIZE_BYTES = 8;
	static final int DOUBLE_SIZE_BYTES = 8;

	/**
	 * RBG which buffer size value is greater than specified by BUFFER_LIMIT
	 * will be allocated direct in the memory.
	 */
	private static final long BUFFER_LIMIT = 10000000; // ten millions bytes.

	static {
		@SuppressWarnings("unused")
		// used, used.
		SecurityManager manager = new SecurityManager();
		try {
			Class.forName("org.randomness.NativeEntropy");
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
	}

	// /////////////////////////////////////////////////////////////////////
	// //////////////////////// INSTANCE ///////////////////////////////////
	// /////////////////////////////////////////////////////////////////////

	/**
	 * View of this randomness as java.util.Random.
	 */
	java.util.Random random;

	static final Map<String, Class<? extends Randomness>> SPI = new HashMap<String, Class<? extends Randomness>>();

	/**
	 * <i>PROVISIONAL API, WORK IN PROGRESS: </i>Associate the specified
	 * <i>algorithm</i> with specified <i>provider</i>. To instantiate algorithm
	 * from the specified provider it should have default constructor (without
	 * parameters).
	 * <p>
	 * If a algorithm with the same name exist and it provider was previously
	 * added using map(), it is replaced by the new service.
	 * 
	 * @param algorithm
	 *            the string constrains readable name of algorithm which is
	 *            producing randomness (possibly with provider prefix or suffix)
	 * @param provider
	 *            the class-provider with default constructor implementing the
	 *            associated algorithm.
	 * @throws IllegalArgumentException
	 *             if algorithm or provider is <code>null</code> or if provider
	 *             does not have default constructor.
	 */
	public static void map(String algorithm,
			Class<? extends Randomness> provider) {

		// try {
		// provider.getConstructor(); // obtain default constructor.
		// } catch (Exception e) {
		// throw new IllegalArgumentException(
		// "Provider does'n provide default constructor for algorythm.");
		// }
		// SPI.put(algorithm, provider);

		throw new UnsupportedOperationException();
	}

	/**
	 * Default constructor.
	 */
	protected Randomness() {
	}

	// ///////////////////////////////////////////////////////////
	// ///////////////// ABSTRACT RBG FUNCTIONS //////////////////
	// ///////////////////////////////////////////////////////////
	/**
	 * Tells whether or not this RBG is open to generate random bytes.
	 */
	public abstract boolean isOpen();

	/**
	 * The <b>instantiate function</b> determines the <i>initial internal
	 * state</i> of RBG using the instantiate algorithm. A RBG shall be
	 * instantiated prior to the generation of random bits.
	 * <p>
	 * If RBG has already initiated a generate operation, then an invocation of
	 * this method will block until the first operation is complete. If RBG
	 * already initiated a generate function, then an invocation of instantiate
	 * function will block until the generate operation is complete.
	 * <p>
	 * Opposite to {@linkplain Randomness#close() uninstantiate} function.
	 */
	public abstract void reset();

	/**
	 * The <b>generate function</b> generates the requested random bits using
	 * the <i>generate algorithm</i>.
	 * <p>
	 * Transfers a sequence generated bytes from this RBG into the given buffer.
	 * An attempt is made to read up to <i>r</i> bytes from RBG, where <i>r</i>
	 * is the number of bytes <i>remaining</i> in the buffer, that is,
	 * <tt>buffer.remaining()</tt>, at the moment this method is invoked.
	 * <p>
	 * Suppose that a byte sequence of length <i>n</i> is read, where <tt>0</tt>
	 * &nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>.
	 * This byte sequence will be transferred into the buffer so that the first
	 * byte in the sequence is at index <i>p</i> and the last byte is at index
	 * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>&nbsp;<tt>-</tt>&nbsp;<tt>1</tt>,
	 * where <i>p</i> is the buffer's position at the moment this method is
	 * invoked. Upon return the buffer's position will be equal to
	 * <i>p</i>&nbsp;<tt>+</tt>&nbsp;<i>n</i>; its limit will not have changed.
	 * As many bytes as possible are transferred into each buffer, hence the
	 * final position is guaranteed to be equal to that buffer's limit. Also, a
	 * read operation might not fill the buffer, and in fact it might not read
	 * any bytes at all. Whether or not it does so depends upon the nature and
	 * state of the RBG.
	 * <p>
	 * This method may be invoked at any time. If another thread has already
	 * initiated a read operation upon this RBG, however, then an invocation of
	 * this method will block until the first operation is complete.
	 * <p>
	 * Calling <i>{@linkplain #close() uninstantiate function}</i> in interrupt
	 * this metod normally (without exceptions).
	 * 
	 * @param dst
	 *            The buffer into which random bytes are to be transferred.
	 * 
	 * @return The number of bytes read from RBG, possibly zero, or <tt>-1</tt>
	 *         if the RBG has reached end-of-stream.
	 * 
	 * @throws NullPointerException
	 *             if <code>buffer</code> is <code>null</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for reading (is
	 *             {@linkplain Randomness#close() closed}).
	 * 
	 */
	@Override
	public abstract int read(ByteBuffer dst);

	/**
	 * Reads a sequence of random bytes from this RBG into the given buffers.
	 * <p>
	 * Scattering reads are often useful when required to produce several
	 * fixed-length (or not) segments with randomness bytes. Also, some,
	 * especially fixed-length blocks generators can be much more efficient for
	 * scattering reads if block size is equal to <i>
	 * {@linkplain Randomness#minlen() minlen}</i> or multiply of it.
	 * <p>
	 * An invocation of this method of the form <tt>r.read(dsts)</tt> behaves in
	 * exactly the same manner as the invocation:
	 * 
	 * <blockquote>
	 * 
	 * <pre>
	 * r.read(dsts, 0, dsts.length);
	 * </pre>
	 * 
	 * </blockquote>
	 * 
	 * @param dsts
	 *            The buffers into which bytes are to be transferred
	 * 
	 * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the
	 *         RBG has reached end-of-stream
	 * @throws NullPointerException
	 *             if one of ByteBuffers in <code>dsts</code> or array itself is
	 *             <code>null</code>.
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for reading.
	 * 
	 * 
	 * @see Randomness#read(ByteBuffer)
	 */
	@Override
	public final long read(ByteBuffer[] dsts) {
		return read(dsts, 0, dsts.length);
	}

	/**
	 * Reads a sequence of bytes from this RBG into a subsequence of the given
	 * buffers.
	 * <p>
	 * An invocation of this method attempts to read up to <i>r</i> bytes from
	 * this RBG, where <i>r</i> is the total number of bytes remaining the
	 * specified subsequence of the given buffer array, that is,
	 * 
	 * <blockquote>
	 * 
	 * <pre>
	 * dsts[offset].remaining()
	 *     + dsts[offset+1].remaining()
	 *     + ... + dsts[offset+length-1].remaining()
	 * </pre>
	 * 
	 * </blockquote>
	 * 
	 * at the moment that this method is invoked.
	 * 
	 * <p>
	 * Suppose that a byte sequence of length <i>n</i> is read, where <tt>0</tt>
	 * &nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;<i>r</i>. Up
	 * to the first <tt>dsts[offset].remaining()</tt> bytes of this sequence are
	 * transferred into buffer <tt>dsts[offset]</tt>, up to the next
	 * <tt>dsts[offset+1].remaining()</tt> bytes are transferred into buffer
	 * <tt>dsts[offset+1]</tt>, and so forth, until the entire byte sequence is
	 * transferred into the given buffers. As many bytes as possible are
	 * transferred into each buffer, hence the final position of each updated
	 * buffer, except the last updated buffer, is guaranteed to be equal to that
	 * buffer's limit.
	 * 
	 * <p>
	 * This method may be invoked at any time. If another thread has already
	 * initiated a read operation upon this RBG, however, then an invocation of
	 * this method will block until the first operation is complete.
	 * </p>
	 * This method behaves exactly as specified in the
	 * {@linkplain #read(ByteBuffer) generate function}.
	 * 
	 * @param dsts
	 *            The buffers into which bytes are to be transferred
	 * 
	 * @param offset
	 *            The offset within the buffer array of the first buffer into
	 *            which bytes are to be transferred; must be non-negative and no
	 *            larger than <tt>dsts.length</tt>
	 * 
	 * @param length
	 *            The maximum number of buffers to be accessed; must be
	 *            non-negative and no larger than <tt>dsts.length</tt>
	 *            &nbsp;-&nbsp;<tt>offset</tt>
	 * 
	 * @return The number of bytes read, possibly zero, or <tt>-1</tt> if the
	 *         RBG has reached end-of-stream
	 * 
	 * @throws IndexOutOfBoundsException
	 *             If the preconditions on the <tt>offset</tt> and
	 *             <tt>length</tt> parameters do not hold.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for reading
	 * @throws NullPointerException
	 *             if one of ByteBuffers in <code>dsts</code> or array itself is
	 *             <code>null</code>.
	 */
	@Override
	public final long read(ByteBuffer[] dsts, int offset, int length) {
		if ((offset < 0) || (length < 0) || (offset > dsts.length - length))
			throw new IndexOutOfBoundsException();

		long transfered = 0;
		final int count = offset + length;
		for (int i = offset, read = 0; i < count; i++) {

			if ((read = this.read(dsts[i])) != -1) {
				transfered += read;
			} else
				return -1; // end-of-stream
		}

		return transfered;
	}

	/**
	 * Transfers a sequence generated bytes from this RBG into the given array.
	 * <p>
	 * This method behaves exactly as specified in the
	 * {@linkplain #read(ByteBuffer) generate function}.
	 * 
	 * @see Randomness#read(ByteBuffer)
	 * @param bytes
	 *            a byte array into which random bytes are to be transferred
	 * @return The number of bytes read, possibly zero.
	 * @throws NullPointerException
	 *             if array is <code>null</code>.
	 */
	public final int read(byte[] bytes) {
		return read(ByteBuffer.wrap(bytes));
	}

	/**
	 * <i>PROVISIONAL API, WORK IN PROGRESS:</i> Reads <i>asynchronously</i>
	 * sequence of bytes in <i>non-blocking</i> mode from this channel into the
	 * given buffer, retrieving result in the <i>future</i> when operation
	 * {@linkplain Future#isDone() is done}.
	 * 
	 * @param dst
	 *            destination buffer
	 * @return {@link Future} result.
	 */
	public final Future<Integer> readFuture(ByteBuffer dst) {
		// TODO read in future.
		return null;
	}

	/**
	 * Attempts to read from this RBG into the given buffer, if generate
	 * function is not owned by other thread.
	 * <p>
	 * This method behaves exactly as specified in the
	 * {@linkplain #read(ByteBuffer) generate function} except that returns
	 * immediately if generate function is owned by other thread.
	 * 
	 * @param buffer
	 *            The buffer into which random bytes are to be transferred.
	 * @return The number of bytes read from RBG, possibly zero, or <tt>-1</tt>
	 *         if the RBG is owned by other thread.
	 */
	public abstract int tryRead(ByteBuffer buffer);

	/**
	 * <i>PROVISIONAL API, WORK IN PROGRESS:</i> Reads a sequence of bytes in
	 * <i>non-blocking</i> mode from this channel into the {@link SourceChannel}
	 * ().
	 * <p>
	 * Source channel can be managaned by {@link Selector} to do a <i>readiness
	 * selection</i> of generated bytes.
	 * 
	 * 
	 * @param bytes
	 *            number of bytes to read
	 * @return source channel where from random bytes can be aquired.
	 */
	public final SourceChannel readSink(final int bytes) {
		SourceChannel sourceChannel = null;

		try {
			Pipe pipe = Pipe.open();
			sourceChannel = pipe.source();
			final SinkChannel sinkChannel = pipe.sink();

			new Thread(new Runnable() {

				@Override
				public void run() {
					ByteBuffer buffer = newBuffer(bytes);
					Randomness.this.read(buffer);
					try {
						sinkChannel.write(buffer);
						sinkChannel.close();
					} catch (IOException e) {
						// hide
					}
				}

			}).start();

		} catch (IOException e) {
			// hide
		}

		return sourceChannel;
	}

	/**
	 * <i>PROVISIONAL API, WORK IN PROGRESS: </i>Open a server associated with
	 * <code>this</code> RBG on specified port.
	 * 
	 * @param address
	 * @return <code>this</code>
	 */
	public final Randomness bind(SocketAddress address) {
		// TODO create associated server
		return this;
	}

	/**
	 * The <b>uninstantiate function</b> zeroizes the internal state of RBG
	 * interrupting generate function, if proceed. Opposite to
	 * {@linkplain Randomness#reset() instantiate} function.
	 * <p>
	 * <h3>Asynchronous closability</h3>
	 * If RBG blocked on generate function than another thread can invoke RBG
	 * close method. This will cause to interrupt generate function without
	 * throwing any exceptions and close RBG.
	 * 
	 * This method may be invoked at any time. If some other thread has already
	 * invoked it, however, then another invocation will block until the first
	 * invocation is complete, after which it will return without effect.
	 * <p>
	 * After a RBG is closed, any further attempt to invoke
	 * {@linkplain Randomness#read(ByteBuffer) read} operations upon it will
	 * cause a <code>NonReadableChannelException</code> to be thrown.
	 * <p>
	 * The closing status can be tested runtime via {@linkplain #isOpen()}
	 * method.
	 * <p>
	 * The closed status of the RBG is cleared by {@linkplain #reset() reset}
	 * function.
	 */
	@Override
	public abstract void close() /* throws IOException */;

	/**
	 * Returns the name of the <i>algorithm</i> (or process) implemented by this
	 * RBG object <i> (optional operation)</i>.
	 * <p>
	 * In general case, <code>toString</code> description can contain all
	 * necessary information about RNG. If type of current RBG is undefined use
	 * <code>UNKNOWN</code> as type mark instead.
	 * 
	 * @return the name of the algorithm, or <code>UNKNOWN</code> if the
	 *         algorithm name cannot be determined.
	 */
	@Override
	public abstract String toString();

	/**
	 * <i>Minlen</i> is the minimum block of bytes essentially produced per one
	 * iteration of generate function <i>(optional operation)</i>.
	 * <p>
	 * This method may provide additional information about generator to
	 * configure generation process more essential for generator. For example,
	 * this method should used as follows:
	 * <p>
	 * <code>Randomness rnd = Cryptorandomness.from(CSPRNG.SHA1);<br>
		ByteBuffer buffer = ByteBuffer.allocate(rnd.minlen() * MULTIPLIER);<br>
		rnd.read(buffer); // essential for generator. may be optimized.</code>
	 * 
	 * @return number of bytes generated by RBG per one iteration
	 * 
	 */
	public abstract int minlen();

	// //////////////////////////////////////////////////////////////
	// ////////////////// GENERATION METHODS ////////////////////////
	// //////////////////////////////////////////////////////////////

	/**
	 * Return's next generated random 1-bit <code>boolean</code> value (like
	 * coin flip). Returned values are chosen pseudorandomly with
	 * (approximately) uniform distribution from <code>true</code> or
	 * <code>false</code> with equal probability.
	 * <p>
	 * It is important to remember, that <code>boolean</code> values are hold in
	 * platform dependent way (depends from JVM). For large <code>boolean</code>
	 * arrays is better to use something like <code>java.util.BitSet</code>.
	 * 
	 * @see <a href="http://en.wikipedia.org/wiki/Bit">Wikipedia - Bit</a>
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.5">JLS
	 *      - 4.2.5 The boolean Type and boolean Values</a>
	 * @return newly generated random <code>boolean</code> value.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public boolean nextBoolean() {
		return (nextByte() >>> 7) != 0;
	}

	/**
	 * Return's next generated <code>boolean</code> with a specified probability
	 * of returning <code>true</code>, else returning <code>false</code>.
	 * <p>
	 * Uses 32-bit precision.
	 * 
	 * @param probability
	 *            <tt>probability</tt> must be between 0.0 and 1.0, inclusive.
	 * @return the <code>next</code> generated
	 */
	public final boolean nextProbability(final float probability) {
		if (probability < 0.0f || probability > 1.0f)
			throw new IllegalArgumentException(
					"probability must be between 0.0 and 1.0 inclusive.");
		if (probability == 0.0)
			return false; // fix half-open issues
		else if (probability == 1.0)
			return true; // fix half-open issues

		return ((nextInt() >>> 8) / ((float) (1 << 24))) < probability;
	}

	/**
	 * Return's next generated random 8-bit <code>byte</code> value. Returned
	 * values are chosen pseudorandomly with (approximately) uniform
	 * distribution from range {@link Byte#MIN_VALUE} to {@link Byte#MAX_VALUE}.
	 * 
	 * @see <a href="http://en.wikipedia.org/wiki/Byte">Wikipedia - Byte</a>
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.1">JLS
	 *      - 4.2.1 Integral Types and Values</a>
	 * @return newly generated random byte value in range [
	 *         <code>-128..127</code>].
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public byte nextByte() {
		return (byte) (nextInt() >>> 24);
	}

	/**
	 * Return's next generated random 16-bit <code>short</code> () value
	 * (typically from <code>nextInt</code> value returned two most significant
	 * bytes).
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.1">JLS
	 *      - 4.2.1 Integral Types and Values</a>
	 * 
	 * @return newly generated random <code>short</code> value in range
	 *         <code>[-32768..32767]</code>
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public short nextShort() {
		return (short) (nextInt() >>> 16);
	}

	/**
	 * Return's next generated random unsigned 16-bit <code>char</code> value
	 * <code>UNICODE</code> encoded. Returned values are chosen pseudorandomly
	 * with (approximately) uniform distribution from range
	 * {@link Character#MIN_VALUE} to {@link Character#MAX_VALUE}.
	 * <p>
	 * Can be used instead of <i>unsigned short</i>.
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.1">JLS
	 *      - 4.2.1 Integral Types and Values</a>
	 * 
	 * @return newly generated random <code>char</code> value (2 byte
	 *         <code>unicode</code>) in range [
	 *         <code>\u0000..\uFFFF] = [0..65535]</code> .
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public final char nextChar() {
		return (char) (nextShort() & 0xFFFF);
	}

	/**
	 * Return's next randomly generated 8-bit <code>char</code> value
	 * <code>US-ASCII</code> encoded.
	 * <p>
	 * Can be used instead of <i>unsigned byte</i>.
	 * 
	 * @return newly generated US-ASCII symbol.
	 */
	public final char nextCharASCII() {
		return (char) (nextByte() & 0xFF);
	}

	/**
	 * Return's next generated random 32-bit <code>int</code> value. Returned
	 * values are chosen randomly with (approximately) uniform distribution from
	 * range {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}.
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.1">JLS
	 *      - 4.2.1 Integral Types and Values</a>
	 * 
	 * @return newly generated random <code>int</code> value in range
	 *         <code>[-2147483648...2147483647]</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public int nextInt() {
		ByteBuffer intOne = ByteBuffer.allocate(INT_SIZE_BYTES);
		this.read(intOne);
		return ((ByteBuffer) intOne.flip()).getInt();
	}

	/**
	 * Return's next generated random <code>int</code> value drawn uniformly
	 * from <code>0</code> to <code>n-1</code>.
	 * <p>
	 * Suffice it to say, n must be > 0, or an IllegalArgumentException is
	 * raised.
	 * 
	 * @return newly generated random <code>int</code> value in range
	 *         <code>[0...n-1]</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 * @throws IllegalArgumentException
	 *             if <code>n < 0</code>
	 */
	public final int nextInt(final int n) {
		if (n <= 0)
			throw new IllegalArgumentException("n must be > 0");

		// return (int) ((n * (long) (nextInt() >>> 1)) >> 31);

		if ((n & -n) == n) // i.e., n is a power of 2
			return (int) ((n * (long) (nextInt() >>> 1)) >> 31);

		int bits, val;
		do {
			bits = (nextInt() >>> 1);
			val = bits % n;
		} while (bits - val + (n - 1) < 0);
		return val;
	}

	/**
	 * Return's next generated random 32-bit floating-point <code>float</code>
	 * () value between <code>0.0</code> (inclusive) and <code>1.0</code>
	 * (exclusive). Returned values are chosen randomly with (approximately)
	 * uniform distribution greater than or equal to <code>0.0</code> and less
	 * than <code>1.0</code>.
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.3">JLS
	 *      - 4.2.3 Floating-Point Types, Formats, and Values</a>
	 * @see <a href="http://en.wikipedia.org/wiki/IEEE_754-2008">Wikipedia -
	 *      IEEE 754</a>
	 * 
	 * @return newly generated random <code>float</code> value in range
	 *         <code>[0..1)</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public float nextFloat() {
		return (nextInt() >>> 8) / ((float) (1 << 24));
	}

	/**
	 * Return's next generated random 64-bit <code>long</code> value. Returned
	 * values are chosen randomly with (approximately) uniform distribution from
	 * range {@link Long#MIN_VALUE} to {@link Long#MAX_VALUE}.
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.1">JLS
	 *      - 4.2.1 Integral Types and Values</a>
	 * 
	 * @return newly generated random <code>long</code> value in range
	 *         <code>[-9223372036854775808...9223372036854775807]</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public long nextLong() {
		ByteBuffer longOne = ByteBuffer.allocate(LONG_SIZE_BYTES);
		read(longOne);
		return ((ByteBuffer) longOne.rewind()).getLong();
	}

	/**
	 * Return's next generated random <code>long</code> value drawn uniformly
	 * from <code>0</code> to <code>n-1</code>.
	 * <p>
	 * Suffice it to say, n must be > 0, or an IllegalArgumentException is
	 * raised.
	 * 
	 * @return newly generated random <code>int</code> value in range
	 *         <code>[0...n-1]</code>.
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 * @throws IllegalArgumentException
	 *             if <code>n < 0</code>
	 */
	public final long nextLong(final long n) {
		if (n <= 0)
			throw new IllegalArgumentException("n must be > 0");

		long bits, val;
		do {
			bits = (((((long) nextInt()) << 32) + (long) nextInt()) >>> 1);
			val = bits % n;
		} while (bits - val + (n - 1) < 0);
		return val;
	}

	/**
	 * Return's next generated random 64-bit floating-point <code>double</code>
	 * value between <code>0.0</code> (inclusive) and <code>1.0</code>
	 * (exclusive). Returned values are chosen randomly with (approximately)
	 * uniform distribution greater than or equal to <code>0.0</code> and less
	 * than <code>1.0</code>.
	 * 
	 * @see <a
	 *      href="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.2.3">JLS
	 *      - 4.2.3 Floating-Point Types, Formats, and Values</a>
	 * @see <a href="http://en.wikipedia.org/wiki/IEEE_754-2008">Wikipedia -
	 *      IEEE 754</a>
	 * @return newly generated random <code>double</code> value greater than or
	 *         equal to 0.0 and less than 1.0..
	 * 
	 * @throws NonReadableChannelException
	 *             If this RBG was not opened for generation.
	 */
	public double nextDouble() {
		int l = nextInt();
		int r = nextInt();
		return ((((long) (l >>> 6)) << 27) + (r >>> 5)) / (double) (1L << 53);
	}

	// /**
	// * @return the next random, uniformly distributed, <tt>float</tt> value,
	// * greater than or equal to 0 and less than 1.
	// */
	//
	// public float nextFloat1() {
	// return (float) ((nextInt() & 0x7FFFFFFF) / (0x7FFFFFFF * 1.0));
	// }

	// /**
	// * @return the next random, uniformly distributed, <tt>double</tt> value,
	// * greater than or equal to 0 and less than 1.
	// */
	//
	// public double nextDouble1() {
	// return (double) ((nextLong() & 0x7FFFFFFFFFFFFFFFl) /
	// (0x7FFFFFFFFFFFFFFFl * 1.0));
	// }

	/**
	 * Generates a random string of hex characters of specified
	 * <code>length</code>.
	 * <p>
	 * The generated string will be random, but not cryptographically secure. To
	 * generate cryptographically secure strings, use
	 * <code>nextSecureHexString</code>
	 * </p>
	 * <p>
	 * <strong>Preconditions</strong>:
	 * <ul>
	 * <li><code>len > 0</code> (otherwise an IllegalArgumentException is
	 * thrown.)</li>
	 * </ul>
	 * </p>
	 * 
	 * @param length
	 *            the length of the string to be generated
	 * @return random string of hex characters of length <code>len</code>
	 * 
	 * @throws IllegalArgumentException
	 *             if <code>len < 0</code>
	 */
	public String nextHexString(int length) {
		if (length <= 0) {
			throw new IllegalArgumentException("length must be positive: "
					+ length);
		}

		// Initialize output buffer
		StringBuffer outBuffer = new StringBuffer();

		// Get int(len/2)+1 random bytes
		byte[] randomBytes = new byte[(length / 2) + 1];
		this.read(randomBytes);

		// Convert each byte to 2 hex digits
		for (int i = 0; i < randomBytes.length; i++) {
			Integer c = Integer.valueOf(randomBytes[i]);

			/*
			 * Add 128 to byte value to make interval 0-255 before doing hex
			 * conversion. This guarantees <= 2 hex digits from toHexString()
			 * toHexString would otherwise add 2^32 to negative arguments.
			 */
			String hex = Integer.toHexString(c.intValue() + 128);

			// Make sure we add 2 hex digits for each byte
			if (hex.length() == 1) {
				hex = "0" + hex;
			}
			outBuffer.append(hex);
		}
		return outBuffer.toString().substring(0, length);
	}

	/**
	 * Returns new instance of ByteBuffer with specified capacity.
	 * <p>
	 * Called by buffered and reversed RBG to instantiate their internal
	 * buffers. Users can override this method to provide custom buffer
	 * creation.
	 * <p>
	 * The default implementations look's:
	 * <p>
	 * <code>return bufferSize > BUFFER_LIMIT ? 
		ByteBuffer.allocateDirect(bufferSize) 
				: ByteBuffer.allocate(bufferSize);</code>
	 * <p>
	 * where <code>BUFFER_LIMIT</code> is equal to 10 000 000 bytes.
	 * 
	 * @param bufferSize
	 *            size of new buffer
	 * @return the newly allocated buffer (not <code>null</code>).
	 * 
	 * 
	 */
	protected ByteBuffer newBuffer(int bufferSize) {
		return bufferSize > BUFFER_LIMIT ? //
		ByteBuffer.allocateDirect(bufferSize) // direct
				: ByteBuffer.allocate(bufferSize); // non-direct
	}

	// //////////////////////////////////////////////////////////
	// //////////////// SERVICE METHODS /////////////////////////
	// //////////////////////////////////////////////////////////

	/**
	 * Represents this RBG as <code>java.util.Random</code>. The java legacy
	 * code use <code>java.util.Random</code> as a main type for randomness.
	 * This method convert this RBG into <code>java.util.Random</code> instance,
	 * to be used instead it. For example:
	 * <p>
	 * <code>BigInteger big = new BigInteger(128, Randomness.from(TRNG.NATIVE).asRandom());
</code>
	 * <p>
	 * <b>Note: Calling of <code>sedSeed(long)</code> method has no effect</b>.
	 * <p>
	 * The view is typically part of the RBG itself (created only once) and
	 * every call return this instance.
	 * 
	 * @see Pseudorandomness#asRandom()
	 * @see Cryptorandomness#asRandom()
	 * 
	 * @return view as <code>java.util.Random</code> over RBG.
	 */
	public Random asRandom() {
		if (random == null)
			random = new Randomness.AsRandom();
		return random;
	}

	/**
	 * Returns new RBG represents <i>mixing</i> of this RBG with specified RBG's
	 * sequence using default <code>XOR</code> mixing function.
	 * <p>
	 * The best overall strategy for obtaining unguessable random numbers is to
	 * obtain input from a number of uncorrelated sources and to mix them with a
	 * strong mixing function. Such a function will preserve the entropy present
	 * in any of the sources, even if other quantities being combined happen to
	 * be fixed or easily guessable (low entropy). This approach may be
	 * advisable even with a good hardware source, as hardware can also fail.
	 * However, this should be weighed against a possible increase in the chance
	 * of overall failure due to added software complexity.
	 * <p>
	 * When combining generators, it is important to understand what we do and
	 * we should be careful to examine the structure of the combination, not
	 * only of the quality of the components. By blindly combining two good
	 * components, it is indeed possible (and not too difficult) to obtain a bad
	 * (worst) RNG.
	 * <p>
	 * The mixing view is not a part of the RBG itself. The two mixing views of
	 * the same RBG is independent from each other, and the RBG become a shared
	 * resource among them.
	 * <p>
	 * This method may overridden to implements the strongest mixing functions.
	 * 
	 * @see <a href="http://www.ietf.org/rfc/rfc4086.txt">RFC 4086: Randomness
	 *      Requirements for Security. Sections 5. Mixing, 5.1. A Trivial Mixing
	 *      Function, p. 16-17</a>
	 * 
	 * @param randomness
	 *            a RBG sequence to be mixed
	 * @return mixing of RBG with XOR mixing function.
	 * @throws IllegalArgumentException
	 *             if method calls without passing any randomness to mix.
	 */
	public final Randomness mixing(Randomness... randomness) {
		if (randomness.length == 0)
			throw new IllegalArgumentException("There is no RBG to mix.");

		return new Randomness.MixingXOR(this, randomness);
	}

	/**
	 * Takes bytes generated by an underling <code>Randomness</code> and
	 * reverses the order in each small window of configurable size
	 * (byte-by-byte). The following example illustrate how reverse function is
	 * works: <blockquote> <code>
	 * <pre>
	 * Randomness r = Pseudorandomness.from(PRNG.XOR_SHIFT);
	 * r = r.reversed(4); 
	 * r.read(ByteBuffer.allocate(8));</code> </pre>
	 * <p>
	 * The window size is 4. Read operation twice fill window, and reverse it
	 * content while writing into buffer. So the following code will work in
	 * next manner: <code><pre>
	 * First window: [-66, -110, -46, -115]
	 * Second window: [50, 13, -46, 100]
	 * Final buffer content: [-115, -46, -110, -66, 100, -46, 13, 50]
	 * </pre></code> The reversed view is not a part of the RBG itself. The two
	 * reversed views of the same RBG is independent from each other, and the
	 * RBG become a shared resource among them.
	 * 
	 * @param windowSize
	 *            - a window size in bytes
	 * @return Reversed <code>Randomness</code>.
	 * 
	 * @throws IllegalArgumentException
	 *             if <code>windowSize < 0</code>
	 */
	public final Randomness reversed(final int windowSize) {
		if (windowSize == 0)
			return this;

		return new Randomness.Reversed(windowSize);
	}

	/**
	 * Shuffle uses one RBG to shuffle the output produced by another RBG to
	 * obliterate sequential correlations to produce non-linear output.
	 * <p>
	 * To initialize Shuffle, pass it two RBG's. The first RBG is used to
	 * generate a table of random output and the second is used to choose one
	 * from the table. The table size is determined by {@link #minlen() minlen}
	 * value of shuffled RBG's.
	 * <p>
	 * The shuffle view is not a part of the RBG itself. The two shuffle views
	 * of the same RBG is independent from each other, and the RBG become a
	 * shared resource among them.
	 * 
	 * @param that
	 *            the RBG to shuffle with
	 * 
	 * @return <code>this</code>
	 */
	public final Randomness shuffle(Randomness that) {
		return new Shuffle(this, that, this.minlen() * this.minlen());
	}

	// //////////////////////////////////////////////////////////////
	// ////////////////// PACKAGE-PRIVATE ////////////////////////
	// //////////////////////////////////////////////////////////////
	/*
	 * Helper function to convert a long into a byte array (least significant
	 * byte first).
	 */
	static final byte[] longToByteArray(long l) {
		byte[] retVal = new byte[8];

		for (int i = 0; i < 8; i++) {
			retVal[i] = (byte) l;
			l >>= 8;
		}

		return retVal;
	}

	static final byte[] bufferToArray(ByteBuffer buffer) {

		if (buffer.hasArray())
			return buffer.array();

		// buffer.rewind();
		byte[] bytes = new byte[buffer.remaining()];
		buffer.get(bytes);

		return bytes;
	}

	/**
	 * Calculate the buffer length from the <i>minlen</i> value.
	 * 
	 * @param minlen
	 *            lenght of output block produced by randomness per iteration.
	 * @return buffer length
	 */
	static final int bufferlen(Randomness randomness) {
		final int minlen = randomness.minlen();
		final boolean isPseudo = (randomness instanceof Pseudorandomness);
		// bufferlen = multiplier * minlen.
		if (minlen <= 16) {
			return isPseudo ? 640 : 160;
		}
		if (minlen <= 24) {
			return isPseudo ? 960 : 240;
		}
		if (minlen <= 64) {
			return isPseudo ? 2560 : 640;
		}
		return minlen;
	}

	/**
	 * View as <code>java.util.Random</code> over Randomness and
	 * Pseudorandomness.
	 * 
	 * @author Anton Kabysh
	 * 
	 */
	final class AsRandom extends java.util.Random {
		/**
		 * Initialization flag to permit calls to setSeed to succeed only while
		 * executing the Random constructor. We can't allow others since it
		 * would cause setting seed in one part of a program to unintentionally
		 * impact other usages by the thread.
		 */
		boolean initialized;

		public AsRandom() {
			super();
			initialized = true;
		}

		/**
		 * serial
		 */
		private static final long serialVersionUID = 4756758871717944514L;

		@Override
		public final boolean nextBoolean() {
			return Randomness.this.nextBoolean();
		}

		@Override
		public final int nextInt() {
			return Randomness.this.nextInt();
		}

		@Override
		public final long nextLong() {
			return Randomness.this.nextLong();
		}

		@Override
		public final float nextFloat() {
			return Randomness.this.nextFloat();
		}

		@Override
		public final double nextDouble() {
			return Randomness.this.nextDouble();
		}

		@Override
		public final void nextBytes(byte[] bytes) {
			Randomness.this.read(bytes);
		}

		@Override
		public final String toString() {
			return Randomness.this.toString();
		}

		@Override
		public final int hashCode() {
			return Randomness.this.hashCode();
		}

		@Override
		public final boolean equals(Object obj) {
			return Randomness.this.equals(obj);
		}

		/**
		 * The general contract of {@code next} is that it returns an
		 * {@code int} value and if the argument {@code bits} is between
		 * {@code 1} and {@code 32} (inclusive), then that many low-order bits
		 * of the returned value will be (approximately) independently chosen
		 * bit values, each of which is (approximately) equally likely to be
		 * {@code 0} or {@code 1}.
		 * 
		 * @param bits
		 *            random bits
		 * @return the next pseudorandom value from this random number
		 *         generator's sequence
		 */
		@Override
		protected int next(int bits) {
			return Randomness.this.nextInt() >>> (32 - bits);
		}

		@Override
		public synchronized void setSeed(long seed) {
			if (Randomness.this instanceof Pseudorandomness && initialized) {
				Pseudorandomness pseudorandomness = (Pseudorandomness) Randomness.this;
				ByteBuffer byteSeed = ByteBuffer.allocate(8);
				byteSeed.putLong(seed).clear();
				pseudorandomness.reseed(byteSeed);
			}
		}
	}

	/**
	 * This class takes bytes generated by an underling RBG and reverses the
	 * byte order in each small window of configurable size.
	 * 
	 * @author Anton Kabysh.
	 * 
	 */
	private final class Reversed extends Randomness {
		/**
		 * Number of already read bytes from the window.
		 */
		private int windowCount;
		/**
		 * Byte window
		 */
		private ByteBuffer window;

		private final ReentrantLock lock = new ReentrantLock();

		/**
		 * Rewersed constructor
		 * 
		 * @param windowSize
		 *            size of reversing window
		 */
		Reversed(int windowSize) {
			window = (ByteBuffer) Randomness.this.newBuffer(windowSize)
					.rewind();
			windowCount = 0;
		}

		@Override
		public final int read(ByteBuffer buffer) {
			if (!isOpen())
				throw new NonReadableChannelException();

			try {
				lock.lock();

				final int numBytes = buffer.remaining();
				final int start = buffer.position();
				int done = 0;

				while (done < numBytes) {
					if (windowCount < 1) {
						window.clear();
						Randomness.this.read(window);
						window.flip();
						windowCount = window.remaining();

					}

					buffer.put(start + done++, window.get(--windowCount));
				}

				return done;

			} finally {
				lock.unlock();
			}
		}

		@Override
		public final int tryRead(ByteBuffer buffer) {
			if (!lock.isLocked())
				return this.read(buffer);
			else
				return -1;
		}

		@Override
		public final void reset() {
			try {
				lock.lock();

				Randomness.this.reset();
				windowCount = 0;
				window.clear();

			} finally {
				lock.unlock();
			}
		}

		private final Randomness context() {
			return Randomness.this;
		}

		@Override
		public final void close() {
			try {
				lock.lock();

				windowCount = 0;
				window.clear();
				Randomness.this.close();

			} finally {
				lock.unlock();
			}
		}

		@Override
		public final boolean isOpen() {
			return Randomness.this.isOpen();
		}

		@Override
		public final String toString() {
			return Randomness.this.toString();
		}

		@Override
		public final int hashCode() {
			int hash = 13;

			hash = 31 * hash + windowCount;
			hash = 31 * hash + window.hashCode();
			hash = 31 * hash + (isOpen() ? 1 : 0);

			return 31 * hash + Randomness.this.hashCode();
		}

		@Override
		public final boolean equals(Object obj) {
			if (obj == this)
				return true;

			if (!(obj instanceof Reversed))
				return false;

			Reversed that = (Reversed) obj;

			if (this.windowCount != that.windowCount)
				return false;

			if (this.isOpen() != that.isOpen())
				return false;

			if (!this.window.equals(that.window))
				return false;

			if (!this.context().equals(that.context()))
				return false;

			return true;
		}

		@Override
		public final boolean nextBoolean() {
			return Randomness.this.nextBoolean();
		}

		@Override
		public final byte nextByte() {
			return (byte) (nextInt() >>> 24);
		}

		@Override
		public final short nextShort() {
			return (short) (nextInt() >>> 16);
		}

		@Override
		public final int nextInt() {
			ByteBuffer intbytes = ByteBuffer.allocate(INT_SIZE_BYTES);
			this.read(intbytes);
			return ((ByteBuffer) intbytes.flip()).getInt();
		}

		@Override
		public final long nextLong() {
			ByteBuffer longbytes = ByteBuffer.allocate(LONG_SIZE_BYTES);
			this.read(longbytes);
			return ((ByteBuffer) longbytes.flip()).getLong();
		}

		@Override
		public final float nextFloat() {
			return (nextInt() >>> 8) / ((float) (1 << 24));
		}

		@Override
		public final double nextDouble() {
			int l = nextInt();
			int r = nextInt();
			return ((((long) (l >>> 6)) << 27) + (r >>> 5))
					/ (double) (1L << 53);
		}

		@Override
		public final int minlen() {
			return Randomness.this.minlen();
		}

	}

	/**
	 * This class represents trivial mixing of several randomness.
	 * 
	 * @author Anton Kabysh
	 * 
	 */
	private static final class MixingXOR extends Randomness {

		private final Randomness[] mixingSequence;

		private final String description;

		public MixingXOR(Randomness parent, Randomness... sequence) {
			mixingSequence = new Randomness[sequence.length + 1];
			mixingSequence[0] = parent;
			System.arraycopy(sequence, 0, mixingSequence, 1, sequence.length);

			StringBuilder builder = new StringBuilder("XOR(");
			final int lastIndex = sequence.length - 1;
			for (int i = 0; i < lastIndex; i++) {
				builder.append(sequence[i].toString()).append(", ");
			}
			builder.append(sequence[lastIndex]);
			builder.append(')');

			description = builder.toString();
		}

		@Override
		public final int read(ByteBuffer buffer) {
			// bytes to read
			final int toRead = buffer.remaining();
			final int mark = buffer.position();

			// buffer to store generated bytes.
			final ByteBuffer tempBytes = newBuffer(toRead);

			mixingSequence[0].read(tempBytes);

			tempBytes.flip();
			buffer.put(tempBytes); // fill remaining first time.
			buffer.position(mark);

			final int longs = toRead / LONG_SIZE_BYTES;
			final int ints = toRead / INT_SIZE_BYTES;

			// main loop:
			// read bytes and put them to buffer XOR-ing with previous content
			for (int j = 1; j < mixingSequence.length; j++) {

				tempBytes.clear();
				mixingSequence[j].read(tempBytes);
				tempBytes.flip();
				buffer.position(mark); // prepare buffer for new data

				int index = mark;

				// transfer long's
				for (int l = 0; l < longs; l++, index += LONG_SIZE_BYTES) {
					buffer.putLong(buffer.getLong(index) ^ tempBytes.getLong());
				}

				// transfer int's
				for (int i = 0; i < ints; i++, index += INT_SIZE_BYTES) {
					buffer.putInt(buffer.getInt(index) ^ tempBytes.getInt());
				}

				// byte-by-byte
				for (; buffer.hasRemaining(); index++) {
					buffer.put((byte) (buffer.get(index) ^ tempBytes.get()));
				}
			}

			return toRead - buffer.remaining();
		}

		@Override
		public final int tryRead(ByteBuffer buffer) {
			// bytes to read
			final int toRead = buffer.remaining();

			// buffer to store generated bytes.
			final ByteBuffer tempBytes = newBuffer(toRead);
			final ByteBuffer xorBytes = newBuffer(toRead);

			int tryRead = mixingSequence[0].tryRead(tempBytes);

			if (tryRead == -1)
				return -1; // failed to read bytes
			else if (tryRead > -1 && tryRead != toRead)
				return 0; // no bytes to read

			// fill buffer first time and reset position
			tempBytes.flip();
			xorBytes.put(tempBytes);
			buffer.clear();

			final int longs = toRead / LONG_SIZE_BYTES;
			final int ints = toRead / INT_SIZE_BYTES;

			// main loop:
			// read bytes and put them to buffer XOR-ing with previous content
			for (int j = 1; j < mixingSequence.length; j++) {

				tempBytes.clear();
				tryRead = mixingSequence[j].tryRead(tempBytes);

				if (tryRead == -1)
					return -1; // failed to read bytes
				else if (tryRead > -1 && tryRead != toRead)
					return 0; // no bytes to read

				tempBytes.flip();
				xorBytes.clear();

				int index = 0;

				// transfer long's
				for (int l = 0; l < longs; l++, index += LONG_SIZE_BYTES) {
					xorBytes.putLong(xorBytes.getLong(index)
							^ tempBytes.getLong());
				}

				// transfer int's
				for (int i = 0; i < ints; i++, index += INT_SIZE_BYTES) {
					xorBytes.putInt(xorBytes.getInt(index) ^ tempBytes.getInt());
				}

				// byte-by-byte
				for (; xorBytes.hasRemaining(); index++) {
					xorBytes.put((byte) (buffer.get(index) ^ tempBytes.get()));
				}
			}

			buffer.put(xorBytes);
			return toRead - buffer.remaining();
		}

		@Override
		public final int minlen() {
			int minminlen = Integer.MAX_VALUE;
			for (int i = 0; i < mixingSequence.length; i++) {
				minminlen = Math.min(mixingSequence[i].minlen(), minminlen);
			}
			return minminlen;
		}

		@Override
		public final void reset() {
			for (int i = 0; i < mixingSequence.length; i++) {
				mixingSequence[i].reset();
			}
		}

		@Override
		final public void close() {
			for (int i = 0; i < mixingSequence.length; i++) {
				mixingSequence[i].close();
			}
		}

		@Override
		public final boolean isOpen() {
			for (int i = 0; i < mixingSequence.length; i++) {
				if (!mixingSequence[i].isOpen())
					return false;
			}
			return true;
		}

		@Override
		public boolean nextBoolean() {
			boolean res = mixingSequence[0].nextBoolean()
					^ mixingSequence[1].nextBoolean();

			for (int i = 2; i < mixingSequence.length; i++) {
				res ^= mixingSequence[i].nextBoolean();
			}
			return res;
		}

		@Override
		public byte nextByte() {
			byte res = (byte) (mixingSequence[0].nextByte() ^ mixingSequence[1]
					.nextByte());

			for (int i = 2; i < mixingSequence.length; i++) {
				res ^= mixingSequence[i].nextByte();
			}
			return res;
		}

		@Override
		public short nextShort() {
			short res = (short) (mixingSequence[0].nextShort() ^ mixingSequence[1]
					.nextShort());

			for (int i = 2; i < mixingSequence.length; i++) {
				res ^= mixingSequence[i].nextShort();
			}
			return res;
		}

		@Override
		public final int nextInt() {
			int res = mixingSequence[0].nextInt() ^ mixingSequence[1].nextInt();

			for (int i = 2; i < mixingSequence.length; i++) {
				res ^= mixingSequence[i].nextInt();
			}
			return res;
		}

		@Override
		public final long nextLong() {
			long res = mixingSequence[0].nextLong()
					^ mixingSequence[1].nextLong();

			for (int i = 2; i < mixingSequence.length; i++) {
				res ^= mixingSequence[i].nextLong();
			}
			return res;
		}

		@Override
		public final boolean equals(Object obj) {
			if (obj == this)
				return true;
			if (!(obj instanceof MixingXOR))
				return false;

			MixingXOR that = (MixingXOR) obj;

			if (this.mixingSequence.length != that.mixingSequence.length)
				return false;

			for (int i = 0; i < mixingSequence.length; i++) {
				if (!(this.mixingSequence[i].equals(that.mixingSequence[i])))
					return false;
			}

			return true;
		}

		@Override
		public final int hashCode() {
			int hash = 17;

			for (int i = 0; i < mixingSequence.length; i++) {
				hash = 31 * hash + mixingSequence[i].hashCode();
			}

			return hash;
		}

		@Override
		public final String toString() {
			return description;
		}
	}

	private static final class Shuffle extends Randomness {

		private final Randomness generatorA;
		private final Randomness generatorB;
		private final int decksize;
		private ByteBuffer deck;

		private final ReentrantLock lock = new ReentrantLock();

		/**
		 * @param ga
		 *            generator to fill shuffle deck
		 * @param gb
		 *            generator to choose from shuffle deck
		 * @param ds
		 *            the size of the shuffle deck
		 */
		Shuffle(Randomness ga, Randomness gb, int ds) {
			generatorA = ga;
			generatorB = gb;
			decksize = ds;
			instantiate();
		}

		private final void instantiate() {
			deck = newBuffer(decksize);

			final int capacity = deck.remaining(); // capacity

			if (capacity != decksize)
				throw new AssertionError("wrong buffer factory");

			for (; deck.hasRemaining();)
				generatorA.read(deck);

			deck.flip();
		}

		@Override
		public final boolean isOpen() {
			return generatorA.isOpen() && generatorB.isOpen();
		}

		@Override
		public final void close() {
			generatorA.close();
			generatorB.close();
		}

		@Override
		public final void reset() {
			generatorA.reset();
			generatorB.reset();
			instantiate();
		}

		@Override
		public final int read(ByteBuffer dst) {

			final int remainig = dst.remaining();
			final int minlen = minlen();
			final int longs = remainig / LONG_SIZE_BYTES;
			final int ints = remainig / INT_SIZE_BYTES;

			try {
				lock.lock();

				// transfer longs
				if (minlen == LONG_SIZE_BYTES && longs > 0) {
					for (int l = 0; l < longs; l++) {
						int index = generatorB.nextInt(decksize
								- LONG_SIZE_BYTES);
						dst.putLong(deck.getLong(index));
						deck.putLong(index, generatorA.nextLong());
					}
				}

				// transfer ints
				if (minlen == INT_SIZE_BYTES && ints > 0) {
					for (int i = 0; i < ints; i++) {
						int index = generatorB.nextInt(decksize
								- INT_SIZE_BYTES);
						dst.putInt(deck.getInt(index));
						deck.putInt(index, generatorA.nextInt());
					}
				}

				// transfer bytes
				for (; dst.hasRemaining();) {
					int index = generatorB.nextInt(decksize - 1 /* byte */);
					dst.put(deck.get(index));
					deck.put(index, generatorA.nextByte());
				}

			} finally {
				lock.unlock();
			}

			while (dst.hasRemaining()) {
				dst.put(nextByte());
			}
			return remainig - dst.remaining();
		}

		public final int tryRead(ByteBuffer buffer) {
			if (!lock.isLocked())
				return this.read(buffer);
			else
				return -1;
		};

		@Override
		public final String toString() {
			return generatorA.toString() + "[" + generatorB.toString() + "]";
		}

		@Override
		public final int minlen() {
			return generatorA.minlen();
		}

		@Override
		public final byte nextByte() {
			try {
				lock.lock();

				final int index = generatorB.nextInt(decksize - 1 /* byte */);
				final byte random = deck.get(index);
				deck.put(index, generatorA.nextByte());
				return random;

			} finally {
				lock.unlock();
			}

			// AtomicInteger index = this.index;
			// int oldindex, newindex;
			// byte random;
			//
			// do {
			// oldindex = index.get();
			// newindex = generatorB.nextInt(decksize - 1 /* byte */);
			// random = deck.get(newindex);
			// } while (!index.compareAndSet(oldindex, newindex));
			//
			// deck.put(newindex, generatorA.nextByte());
			//
			// return random;
		}

		@Override
		public final short nextShort() {

			try {
				lock.lock();

				final int index = generatorB
						.nextInt(decksize - SHORT_SIZE_BYTE);
				final short random = deck.getShort(index);
				deck.putShort(index, generatorA.nextShort());
				return random;

			} finally {
				lock.unlock();
			}

		}

		@Override
		public final int nextInt() {

			try {
				lock.lock();

				final int index = generatorB.nextInt(decksize - INT_SIZE_BYTES);
				final int random = deck.getInt(index);
				deck.putInt(index, generatorA.nextInt());
				return random;

			} finally {
				lock.unlock();
			}

		}

		@Override
		public final long nextLong() {

			try {
				lock.lock();

				final int index = generatorB
						.nextInt(decksize - LONG_SIZE_BYTES);
				final long random = deck.getLong(index);
				deck.putLong(index, generatorA.nextLong());
				return random;

			} finally {
				lock.unlock();
			}

		}

		@Override
		public final float nextFloat() {

			try {
				lock.lock();

				final int index = generatorB.nextInt(decksize
						- FLOAT_SIZE_BYTES);
				final float random = deck.getFloat(index);
				deck.putFloat(index, generatorA.nextFloat());
				return random;

			} finally {
				lock.unlock();
			}

		}

		@Override
		public final double nextDouble() {

			try {
				lock.lock();

				final int index = generatorB.nextInt(decksize
						- DOUBLE_SIZE_BYTES);
				final double random = deck.getDouble(index);
				deck.putDouble(index, generatorA.nextDouble());
				return random;

			} finally {
				lock.unlock();
			}

		}

		@Override
		public final boolean equals(Object obj) {
			if (obj == this)
				return true;

			if (!(obj instanceof Shuffle))
				return false;

			Shuffle that = (Shuffle) obj;

			if (this.decksize != that.decksize)
				return false;

			if (this.isOpen() != that.isOpen())
				return false;

			if (!this.deck.equals(that.deck))
				return false;

			if (!this.generatorA.equals(that.generatorA))
				return false;

			if (!this.generatorB.equals(that.generatorB))
				return false;

			return true;
		}

		@Override
		public final int hashCode() {
			int hash = 11;

			hash = 31 * hash + decksize;
			hash = 31 * hash + (isOpen() ? 1 : 0);
			hash = 31 * hash + deck.hashCode();

			hash = 31 * hash + generatorA.hashCode();
			hash = 31 * hash + generatorB.hashCode();

			return hash;
		}
	}
}
