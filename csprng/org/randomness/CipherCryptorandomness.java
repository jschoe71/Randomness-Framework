package org.randomness;

import java.nio.ByteBuffer;
import java.nio.channels.NonReadableChannelException;
import java.security.GeneralSecurityException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;

/**
 * Cryptorandomness generated from cipher in counter mode. This class is
 * internally buffered with buffer size equal to cipher output block.
 * <p>
 * Supported ciphers:
 * <ol>
 * <li>AES
 * <li>BLOWFISH
 * </ol>
 * 
 * 
 * @author Daniel Dyer (uncommons-math AES Counter)
 * @author Anton Kabysh (randomness version)
 */
final class CipherCryptorandomness extends CryptorandomnessEngine {
	/**
	 * Cryptographic cipher for encryption
	 */
	private final transient Cipher cipher;
	/**
	 * Cipher counter
	 */
	private final transient byte[] counter;
	/**
	 * Size of cipher output block.
	 */
	private int cipherBlock;
	/**
	 * Block of currently generated by cipher data.
	 */
	private transient byte[] currentBlock;
	/**
	 * Internal buffer.
	 */
	private transient byte[] remainder; // remained byte from the output.
	/**
	 * Count for remainder array.
	 */
	private transient int remCount;
	/**
	 * Length of cipher key.
	 */
	private transient final int seedlen;
	/**
	 * Actual algorythm name.
	 */
	private final String algorithm;

	/**
	 * Constructs Cryptorandomness Number generator using specified block cipher
	 * algorithm.
	 * 
	 * @param algorithm
	 *            the algorithm name.
	 */
	public CipherCryptorandomness(String algorithm, int seedlen) {
		try {
			cipher = Cipher.getInstance(algorithm);
			// max key size for specified cipher
			// seedlen = Cipher.getMaxAllowedKeyLength(algorithm) /
			// BITS_PER_BYTE;
			this.seedlen = seedlen;
		} catch (NoSuchAlgorithmException e) {
			throw new InternalError("NoSuchAlgorithmException: " + algorithm
					+ " algorithm is not available.");
		} catch (NoSuchPaddingException e) {
			throw new InternalError("NoSuchPaddingException: " + algorithm
					+ " is not available.");
		}

		// get algorithm name,
		this.algorithm = algorithm.split("/")[0];
		// internal counter
		counter = new byte[seedlen];

		this.reset(); // initialize
	}

	@Override
	protected final void instantiate(final ByteBuffer seed) {
		seed.rewind();
		final byte[] seedBytes = bufferToArray(seed);

		try {
			// key from raw bytes.
			SecretKeySpec skeySpec = new SecretKeySpec(seedBytes, algorithm);
			cipher.init(Cipher.ENCRYPT_MODE, skeySpec);

		} catch (InvalidKeyException e) {
			throw new InternalError(
					"InvalidKeyException: "
							+ cipher.getAlgorithm()
							+ " in counter mode can'not be instantiated from key created with specified seed.");
		}

		// to open
		try {
			// generate block
			currentBlock = nextBlock();
			cipherBlock = currentBlock.length;

			// init counter
			int len = Math.min(seedlen, cipherBlock);
			System.arraycopy(currentBlock, 0, counter, 0, len);

			Arrays.fill(currentBlock, (byte) 0);
		} catch (GeneralSecurityException ex) {
			// Should never happen. If initialisation succeeds
			// without exceptions we should be able to proceed
			// indefinitely without exceptions.
			throw new IllegalStateException(
					"Failed creating random block from cipher.", ex);
		}
	}

	@Override
	public final int read(final ByteBuffer buffer) {
		if (!isOpen())
			throw new NonReadableChannelException();

		try {
			lock.lock();

			final int remaining = buffer.remaining();
			int read = 0;
			int todo;
			byte[] output = remainder;

			// Use remainder from last time
			int r = remCount;
			if (r > 0) {

				// How many bytes?
				todo = (remaining - read) < (cipherBlock - r) ? (remaining - read)
						: (cipherBlock - r);

				// Copy the bytes, bulk
				buffer.put(output, r, todo);

				// zero the buffer
				for (int i = 0; i < todo; i++) {
					output[r++] = 0;
				}

				remCount += todo;
				read += todo;

				// reach end of remainder
				if (remCount == remainder.length) {
					remCount = 0;
				}

			}

			// If we need more bytes, make them.
			while (read < remaining) {
				// Step the state
				try {
					currentBlock = nextBlock();
					output = currentBlock;
				} catch (GeneralSecurityException ex) {
					// Should never happen. If initialisation succeeds
					// without exceptions we should be able to proceed
					// indefinitely without exceptions.
					throw new IllegalStateException(
							"Failed creating next random block.", ex);
				}

				// How many bytes?
				todo = (remaining - read) > cipherBlock ? cipherBlock
						: (remaining - read);

				// Copy the bytes,
				buffer.put(output, 0, todo);

				// zero the buffer
				for (int i = 0; i < todo; i++) {
					output[i] = 0;
				}

				read += todo;
				remCount += todo;
			}

			// Store remainder for next time
			remainder = output;

			read = remaining - buffer.remaining() /* should be zero */;
			byteCounter += read;

			return read;
		} finally {
			lock.unlock();
		}
	}

	/**
	 * Generates a single 128-bit block (16 bytes).
	 * 
	 * @throws GeneralSecurityException
	 *             If there is a problem with the cipher that generates the
	 *             random data.
	 * @return A 16-byte (key size) block of random data.
	 */
	private final byte[] nextBlock() throws GeneralSecurityException {
		incrementCounter();
		return cipher.doFinal(counter);
	}

	private final void incrementCounter() {
		for (int i = 0; i < counter.length; i++) {
			++counter[i];
			if (counter[i] != 0) // Check whether we need to loop again to carry
			// the one.
			{
				break;
			}
		}
	}

	@Override
	public final String toString() {
		return "CSPRNG." + cipher.getAlgorithm();
	}

	@Override
	public final void close() {
		currentBlock = null;
	}

	@Override
	public final int seedlen() {
		return seedlen; // max key size for specified cipher
	}

	@Override
	public final int minlen() {
		return cipherBlock;
	}

	@Override
	public final boolean isOpen() {
		return currentBlock != null;
	}

}
